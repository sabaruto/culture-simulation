// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel BackgroundUpdate

struct Square
{
    // TODO Add pixel position
    int2 position;
    int beliefPosition;
    int beliefLength;
};

struct Belief
{
    float4 color;
};

struct Player
{
    // TODO Create variable number of beliefs
    int2 position;
    int beliefPosition;
    int beliefLength;
};

int width;
int height;
float scale;
float neighbourWeighting;
float squareWeighting;

RWStructuredBuffer<Square> squares;
RWStructuredBuffer<Square> workingSquares;
RWStructuredBuffer<Player> players;
RWStructuredBuffer<Belief> beliefs;

RWStructuredBuffer<float> playerBeliefScales;
RWStructuredBuffer<float> squaresBeliefScales;

RWStructuredBuffer<float> newBeliefScale;
RWStructuredBuffer<float> squareBeliefScale;
RWStructuredBuffer<float> playerBeliefScale;
RWStructuredBuffer<float> neighbourBeliefScale;

RWTexture2D<float4> result;


int2 PositionToPixel(float2 pos)
{
    return int2(0.5 * (width - 1) + pos[0] / scale, 0.5 * (height - 1) + pos[1] / scale);
}

float GetSquareBeliefScale(Square square, int index)
{
    int memberBeliefScaleIndex = square.beliefPosition + index;
    return squaresBeliefScales[memberBeliefScaleIndex];
}

float GetPlayerBeliefScale(Player player, int index)
{
    int memberBeliefScaleIndex = player.beliefPosition + index;
    return playerBeliefScales[memberBeliefScaleIndex];
}

[numthreads(32,1,1)]
void BackgroundUpdate (uint3 id : SV_DispatchThreadID)
{
    Square square = squares[id.x];
    int x = square.position[0];
    int y = square.position[1];
    
    uint beliefIndex = 0;

    // Define and find average of neighbour and current values
    float surroundingSquareIndexes[] = 
    {
        (x-1) * height + y-1,
        x * height + y-1,
        (x+1) * height + y-1,
        (x+1) * height + y,
        (x+1) * height + y+1,
        x * height + y+1,
        (x-1) * height + y+1,
        (x-1) * height + y,
        x * height + y,
        
    };

    int accessableSquares[] = {1, 1, 1, 1, 1, 1, 1, 1, 1};

    if (x == 0)
    {
        accessableSquares[0] = 0;
        accessableSquares[6] = 0;
        accessableSquares[7] = 0;
    }

    if (y == 0)
    {
        accessableSquares[0] = 0;
        accessableSquares[1] = 0;
        accessableSquares[2] = 0;
    }

    if (x + 1 == width)
    {
        accessableSquares[2] = 0;
        accessableSquares[3] = 0;
        accessableSquares[4] = 0;
    }

    if (y + 1 == height)
    {
        accessableSquares[4] = 0;
        accessableSquares[5] = 0;
        accessableSquares[6] = 0;
    }

    int numSurroundingSquares = 0;
    for (uint accessableIndex = 0; accessableIndex < accessableSquares.Length; accessableIndex++)
    {
        numSurroundingSquares += accessableSquares[accessableIndex];
    }

    for (uint indexIndex = 0; indexIndex < surroundingSquareIndexes.Length; indexIndex++)
    {
        int currentIndex = surroundingSquareIndexes[indexIndex];

        if (accessableSquares[indexIndex] == 1)
        {
            for (beliefIndex = 0; beliefIndex < newBeliefScale.Length; beliefIndex++)
            {
                neighbourBeliefScale[beliefIndex] += GetSquareBeliefScale
                (
                    workingSquares[currentIndex], 
                    beliefIndex
                ) / numSurroundingSquares;
            }
        }
    }

    for (beliefIndex = 0; beliefIndex < newBeliefScale.Length; beliefIndex++)
    {
        squareBeliefScale[beliefIndex] = GetSquareBeliefScale(square, beliefIndex) * squareWeighting + neighbourBeliefScale[beliefIndex] * (1 - squareWeighting);

        if (squareBeliefScale[beliefIndex] == 0)
        {
            squareBeliefScale[beliefIndex] = GetSquareBeliefScale(square, beliefIndex);
        }
    }

    // Define and find average player values
    float2 position = square.position;
    

    for (uint playerIndex = 0; playerIndex < players.Length; playerIndex++)
    {
        Player currentPlayer = players[playerIndex];
        float2 distanceVector = position - currentPlayer.position;
        float distance = sqrt(distanceVector[0] * distanceVector[0] + distanceVector[1] * distanceVector[1]);
        float currentWeight = clamp(0.5f - 0.5f * distance * distance, 0, 1);
        
        for (beliefIndex = 0; beliefIndex < playerBeliefScale.Length; beliefIndex++)
        {
            playerBeliefScale[beliefIndex] += currentWeight * GetPlayerBeliefScale(currentPlayer, beliefIndex);
        }
    }

    // Merge the two colors
    float totalBeliefStrength = 0;
    for (beliefIndex = 0; beliefIndex < playerBeliefScale.Length; beliefIndex++)
    {
        newBeliefScale[beliefIndex] = squareBeliefScale[beliefIndex] * neighbourWeighting + playerBeliefScale[beliefIndex] * (1 - neighbourWeighting);

        totalBeliefStrength += newBeliefScale[beliefIndex];
    }
    
    float4 squareColor = float4(0, 0, 0, 0);
    for (beliefIndex = 0; beliefIndex < playerBeliefScale.Length; beliefIndex++)
    {
        squaresBeliefScales[square.beliefPosition + beliefIndex] = newBeliefScale[beliefIndex] / totalBeliefStrength;

        // Update the render color for the square
        // result[square.position] += beliefs[beliefIndex].color * square.beliefStrength[beliefIndex] / 255;
        squareColor += beliefs[beliefIndex].color * GetSquareBeliefScale(square, beliefIndex);
    }

    result[square.position] = squareColor;

    squares[id.x] = square;
}